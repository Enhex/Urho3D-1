#pragma once

#include "../Physics/CollisionShape.h"
#include "../Scene/Component.h"

class NewtonCollision;
class NewtonMesh;
namespace Urho3D
{



    class UrhoNewtonPhysicsWorld;
    class NewtonRigidBody;
    class NewtonMeshObject;
    class Component;

    /// base class for newton collision shapes
    class URHO3D_API NewtonCollisionShape : public Component
    {
        URHO3D_OBJECT(NewtonCollisionShape, Component);
    public:

        friend class UrhoNewtonPhysicsWorld;
        friend class NewtonRigidBody;

        NewtonCollisionShape(Context* context);

        virtual ~NewtonCollisionShape();

        static void RegisterObject(Context* context);



        ///// Set as a box.
        //void SetBox(const Vector3& size, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY);
        ///// Set as a sphere.
        //void SetSphere(float diameter, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY);
        ///// Set as a cylinder.
        //void SetCylinder(float diameter, float height, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY);
        ///// Set as a capsule.
        //void SetCapsule(float diameter, float height, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY);
        ///// Set as a cone.
        //void SetCone(float diameter, float height, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY);
        ///// Set as a triangle mesh from Model. 
        //void SetTriangleMesh(Model* model, unsigned lodLevel = 0, const Vector3& scale = Vector3::ONE, const Vector3& position = Vector3::ZERO,
        //    const Quaternion& rotation = Quaternion::IDENTITY);
        ///// Set as a convex hull from Model.
        //void SetConvexHull(Model* model, unsigned lodLevel = 0, float tolerance = 0.0f, const Vector3& scale = Vector3::ONE, const Vector3& position = Vector3::ZERO,
        //    const Quaternion& rotation = Quaternion::IDENTITY);
        ///// Set as a compound collision generated by newton.
        //void SetCompound(Model* model, unsigned lodLevel = 0, float tolerance = 0.0f, const Vector3& scale = Vector3::ONE, const Vector3& position = Vector3::ZERO,
        //    const Quaternion& rotation = Quaternion::IDENTITY);


        /// Set the positional offset of the shape in local space to the node.
        void SetPositionOffset(Vector3 position) { position_ = position; MarkDirty(true); }

        /// Set the rotational offset of the shape in local space to the node.
        void SetRotationOffset(Quaternion rotation) { rotation_ = rotation; MarkDirty(true); }



        /// Returns the volume of the collision shape (convex only);
        float GetVolume() { return volume_; }

        /// Mark the shape as dirty causing it to be rebuilt by the physics world.
        void MarkDirty(bool dirty = true);
        /// Get the current dirty status.
        bool GetDirty() const { return shapeNeedsRebuilt_; }

        /// Returns the internal newton collision
        NewtonCollision* GetNewtonCollision();


    protected:

        /// Physics world.
        WeakPtr<UrhoNewtonPhysicsWorld> physicsWorld_;
        /// Rigid body.
        WeakPtr<NewtonRigidBody> rigidBody_;
        /// Internal Newton Collision
        NewtonCollision* newtonCollision_ = nullptr;
        /// newton Mesh reference
        WeakPtr<NewtonMeshObject> newtonMesh_ = nullptr;
        /// volume
        float volume_ = 0.0f;
        /// shape dirty flag
        bool shapeNeedsRebuilt_ = true;

        /// Offset position.
        Vector3 position_;
        /// Offset rotation.
        Quaternion rotation_;



        /// optional Model reference
        WeakPtr<Model> model_;
        /// lod level
        unsigned modelLodLevel_ = 0;
        /// model geometry index to sue
        unsigned modelGeomIndx_ = 0;
        /// Hulling tolerance
        unsigned hullTolerance_ = 0.0f;



        /// updates the intenal newton collision pointer to reference the appropriate collision instance from the newton cache based on current parameters.
        void reEvaluateCollision();
        /// implement this in subclasses to create the internal newton collision
        virtual void createNewtonCollision();
        /// Frees the internal collision shape and mesh;
        void freeInternalCollision();

        /// notifies the sibling rigid body of updates if it exists
        void notifyRigidBody();

        /// Called when there is a change to the rigid body component;
        void updateReferenceToRigidBody();

        /// Calculates the effective mass based off density and size. (could be expensive)
        float updateVolume();


        //void formTriangleMeshCollision();
        //bool formConvexHullCollision();
        //bool formCompoundCollision();

        ///forms newtonMesh_ from model geometry for later use.
        bool formTriangleMesh();


        virtual void OnNodeSet(Node* node) override;
    };







    class URHO3D_API NewtonCollisionShape_Box : public NewtonCollisionShape {

        URHO3D_OBJECT(NewtonCollisionShape_Box, NewtonCollisionShape);

    public:
        NewtonCollisionShape_Box(Context* context);
        virtual ~NewtonCollisionShape_Box();

        static void RegisterObject(Context* context);

        /// Set the size of the box
        void SetSize(const Vector3& size) { size_ = size; MarkDirty(true); }

        /// Get the size of the box
        Vector3 GetSize() const { return size_; }

    protected:
        Vector3 size_ = Vector3::ONE;

        virtual void createNewtonCollision() override;

    };

    class URHO3D_API NewtonCollisionShape_Sphere : public NewtonCollisionShape {

        URHO3D_OBJECT(NewtonCollisionShape_Sphere, NewtonCollisionShape);

    public:
        NewtonCollisionShape_Sphere(Context* context);
        virtual ~NewtonCollisionShape_Sphere();

        static void RegisterObject(Context* context);

        /// Set the radius of the box
        void SetRadius(float radius) { radius_ = radius; MarkDirty(true); }

        /// Get the radius of the box
        float GetRadius() const { return radius_; }

    protected:
        float radius_ = 0.5f;

        virtual void createNewtonCollision() override;

    };

    class URHO3D_API NewtonCollisionShape_ConvexHullCompound : public NewtonCollisionShape {

        URHO3D_OBJECT(NewtonCollisionShape_ConvexHullCompound, NewtonCollisionShape);

    public:
        NewtonCollisionShape_ConvexHullCompound(Context* context);
        virtual ~NewtonCollisionShape_ConvexHullCompound();

        static void RegisterObject(Context* context);

        /// Set the radius of the box
        void SetRadius(float radius) { radius_ = radius; MarkDirty(true); }

        /// Get the radius of the box
        float GetRadius() const { return radius_; }

    protected:
        float radius_ = 0.5f;

        virtual void createNewtonCollision() override;

    };


}
